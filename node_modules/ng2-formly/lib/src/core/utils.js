export function getFieldId(formId, options, index) {
    if (options.id)
        return options.id;
    var type = options.type;
    if (!type && options.template)
        type = 'template';
    return [formId, type, options.key, index].join('_');
}
export function getKeyPath(field) {
    if (field['_formlyKeyPath'] !== undefined) {
        return field['_formlyKeyPath'];
    }
    var keyPath = [];
    if (field.key) {
        var pathElements = typeof field.key === 'string' ? field.key.split('.') : field.key;
        for (var _i = 0, pathElements_1 = pathElements; _i < pathElements_1.length; _i++) {
            var pathElement = pathElements_1[_i];
            if (typeof pathElement === 'string') {
                pathElement = pathElement.replace(/\[(\w+)\]/g, '.$1');
                keyPath = keyPath.concat(pathElement.split('.'));
            }
            else {
                keyPath.push(pathElement);
            }
        }
        for (var i = 0; i < keyPath.length; i++) {
            var pathElement = keyPath[i];
            if (typeof pathElement === 'string' && stringIsInteger(pathElement)) {
                keyPath[i] = parseInt(pathElement);
            }
        }
    }
    field['_formlyKeyPath'] = keyPath;
    return keyPath;
}
function stringIsInteger(str) {
    return !isNullOrUndefined(str) && /^\d+$/.test(str);
}
export function getFieldModel(model, field, constructEmptyObjects) {
    var keyPath = getKeyPath(field);
    var value = model;
    for (var i = 0; i < keyPath.length; i++) {
        var path = keyPath[i];
        var pathValue = value[path];
        if (isNullOrUndefined(pathValue) && constructEmptyObjects) {
            if (i < keyPath.length - 1) {
                value[path] = typeof keyPath[i + 1] === 'number' ? [] : {};
            }
            else if (field.fieldGroup) {
                value[path] = {};
            }
            else if (field.fieldArray) {
                value[path] = [];
            }
        }
        value = value[path];
        if (!value) {
            break;
        }
    }
    return value;
}
export function assignModelValue(model, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        var e = path.shift();
        if (!model[e]) {
            model[e] = isNaN(path[0]) ? {} : [];
        }
        assignModelValue(model[e], path, value);
    }
    else {
        model[path[0]] = value;
    }
}
export function getValueForKey(model, path) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        var e = path.shift();
        if (!model[e]) {
            model[e] = isNaN(path[0]) ? {} : [];
        }
        return getValueForKey(model[e], path);
    }
    else {
        return model[path[0]];
    }
}
export function getKey(controlKey, actualKey) {
    return actualKey ? actualKey + '.' + controlKey : controlKey;
}
export function reverseDeepMerge(dest, source) {
    if (source === void 0) { source = undefined; }
    var args = Array.prototype.slice.call(arguments);
    if (!args[1]) {
        return dest;
    }
    args.forEach(function (src, index) {
        if (!index) {
            return;
        }
        for (var srcArg in src) {
            if (isNullOrUndefined(dest[srcArg]) || isBlankString(dest[srcArg])) {
                if (isFunction(src[srcArg])) {
                    dest[srcArg] = src[srcArg];
                }
                else {
                    dest[srcArg] = clone(src[srcArg]);
                }
            }
            else if (objAndSameType(dest[srcArg], src[srcArg])) {
                reverseDeepMerge(dest[srcArg], src[srcArg]);
            }
        }
    });
    return dest;
}
export function isNullOrUndefined(value) {
    return value === undefined || value === null;
}
export function isBlankString(value) {
    return value === '';
}
export function isFunction(value) {
    return typeof (value) === 'function';
}
export function objAndSameType(obj1, obj2) {
    return isObject(obj1) && isObject(obj2) &&
        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);
}
export function isObject(x) {
    return x != null && typeof x === 'object';
}
export function clone(value) {
    if (!isObject(value)) {
        return value;
    }
    return Array.isArray(value) ? value.slice(0) : Object.assign({}, value);
}
export function evalStringExpression(expression, argNames) {
    try {
        return Function.bind.apply(Function, [void 0].concat(argNames.concat("return " + expression + ";")))();
    }
    catch (error) {
        console.error(error);
    }
}
export function evalExpressionValueSetter(expression, argNames) {
    try {
        return Function.bind
            .apply(Function, [void 0].concat(argNames.concat(expression + " = expressionValue;")))();
    }
    catch (error) {
        console.error(error);
    }
}
export function evalExpression(expression, thisArg, argVal) {
    if (expression instanceof Function) {
        return expression.apply(thisArg, argVal);
    }
    else {
        return expression ? true : false;
    }
}
//# sourceMappingURL=utils.js.map